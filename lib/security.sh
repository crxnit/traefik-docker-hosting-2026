#!/bin/bash
# =============================================================================
# security.sh - Server security hardening functions
# =============================================================================
# shellcheck shell=bash

# Guard against multiple sourcing
if [[ -n "${_SECURITY_LOADED:-}" ]]; then
    return 0
fi

# Source common functions if not already loaded
if [[ -z "${_COMMON_LOADED:-}" ]]; then
    SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
    # shellcheck source=lib/common.sh
    source "${SCRIPT_DIR}/common.sh"
fi

_SECURITY_LOADED=true

# =============================================================================
# SSH Hardening
# =============================================================================

# Harden SSH configuration
# Usage: harden_ssh 2222 "john"
harden_ssh() {
    local ssh_port="${1:-22}"
    local allowed_user="${2:-}"
    local ssh_config="/etc/ssh/sshd_config"

    log_info "Hardening SSH configuration..."

    # Backup original config
    backup_file "$ssh_config"

    # Create hardened config
    cat > "${ssh_config}.d/99-hardening.conf" << EOF
# SSH Hardening Configuration
# Generated by security.sh on $(date)

# Change default port
Port ${ssh_port}

# Protocol version
Protocol 2

# Authentication
PermitRootLogin no
PubkeyAuthentication yes
PasswordAuthentication no
PermitEmptyPasswords no
ChallengeResponseAuthentication no
UsePAM yes

# Security options
X11Forwarding no
AllowTcpForwarding no
AllowAgentForwarding no
PermitTunnel no

# Timeouts and limits
ClientAliveInterval 300
ClientAliveCountMax 2
LoginGraceTime 30
MaxAuthTries 3
MaxSessions 3

# Logging
LogLevel VERBOSE

EOF

    # Add allowed user if specified
    if [[ -n "$allowed_user" ]]; then
        echo "AllowUsers ${allowed_user}" >> "${ssh_config}.d/99-hardening.conf"
    fi

    # Test configuration
    if sshd -t; then
        log_info "SSH configuration is valid"
        systemctl reload sshd
        log_info "SSH service reloaded with new configuration"
    else
        log_error "SSH configuration test failed"
        return 1
    fi
}

# Deploy SSH public key for user
# Usage: deploy_ssh_key "john" "ssh-rsa AAAA..."
deploy_ssh_key() {
    local username="$1"
    local public_key="$2"

    local user_home
    user_home=$(getent passwd "$username" | cut -d: -f6)

    if [[ -z "$user_home" ]]; then
        log_error "User $username not found"
        return 1
    fi

    local ssh_dir="${user_home}/.ssh"
    local auth_keys="${ssh_dir}/authorized_keys"

    # Create .ssh directory
    mkdir -p "$ssh_dir"
    chmod 700 "$ssh_dir"

    # Add key if not already present
    if ! grep -qF "$public_key" "$auth_keys" 2>/dev/null; then
        echo "$public_key" >> "$auth_keys"
        chmod 600 "$auth_keys"
        chown -R "${username}:${username}" "$ssh_dir"
        log_info "SSH key deployed for $username"
    else
        log_info "SSH key already exists for $username"
    fi
}

# =============================================================================
# Kernel Hardening
# =============================================================================

# Apply kernel security parameters via sysctl
apply_kernel_hardening() {
    local sysctl_file="/etc/sysctl.d/99-security.conf"

    log_info "Applying kernel hardening parameters..."

    cat > "$sysctl_file" << 'EOF'
# Kernel Security Hardening
# Generated by security.sh

# =============================================================================
# Network Security
# =============================================================================

# Enable IP spoofing protection (reverse path filtering)
net.ipv4.conf.all.rp_filter = 1
net.ipv4.conf.default.rp_filter = 1

# Disable IP source routing
net.ipv4.conf.all.accept_source_route = 0
net.ipv4.conf.default.accept_source_route = 0
net.ipv6.conf.all.accept_source_route = 0
net.ipv6.conf.default.accept_source_route = 0

# Disable ICMP redirects
net.ipv4.conf.all.accept_redirects = 0
net.ipv4.conf.default.accept_redirects = 0
net.ipv6.conf.all.accept_redirects = 0
net.ipv6.conf.default.accept_redirects = 0
net.ipv4.conf.all.send_redirects = 0
net.ipv4.conf.default.send_redirects = 0

# Enable SYN flood protection (SYN cookies)
net.ipv4.tcp_syncookies = 1

# Ignore ICMP broadcasts (Smurf attack protection)
net.ipv4.icmp_echo_ignore_broadcasts = 1

# Ignore bogus ICMP error responses
net.ipv4.icmp_ignore_bogus_error_responses = 1

# Log suspicious packets (spoofed, source routed, redirect)
net.ipv4.conf.all.log_martians = 1
net.ipv4.conf.default.log_martians = 1

# Disable IPv6 if not needed (uncomment to disable)
# net.ipv6.conf.all.disable_ipv6 = 1
# net.ipv6.conf.default.disable_ipv6 = 1

# =============================================================================
# Kernel Protection
# =============================================================================

# Restrict kernel pointer access
kernel.kptr_restrict = 2

# Restrict dmesg access to root
kernel.dmesg_restrict = 1

# Enable ASLR (Address Space Layout Randomization)
kernel.randomize_va_space = 2

# Restrict ptrace scope
kernel.yama.ptrace_scope = 1

# Restrict access to kernel logs
kernel.printk = 3 3 3 3

# Restrict core dumps
fs.suid_dumpable = 0

# =============================================================================
# File System Security
# =============================================================================

# Protect hardlinks and symlinks
fs.protected_hardlinks = 1
fs.protected_symlinks = 1

# Protect FIFOs and regular files
fs.protected_fifos = 2
fs.protected_regular = 2

# =============================================================================
# Performance & Security Balance
# =============================================================================

# TCP keepalive (detect dead connections)
net.ipv4.tcp_keepalive_time = 600
net.ipv4.tcp_keepalive_probes = 5
net.ipv4.tcp_keepalive_intvl = 15

# Reduce TIME_WAIT connections
net.ipv4.tcp_fin_timeout = 30
net.ipv4.tcp_tw_reuse = 1

EOF

    # Apply settings
    sysctl -p "$sysctl_file"
    log_info "Kernel hardening parameters applied"
}

# =============================================================================
# User Management
# =============================================================================

# Create admin user with sudo access
# Usage: create_admin_user "john"
create_admin_user() {
    local username="$1"

    if id "$username" &>/dev/null; then
        log_info "User $username already exists"
    else
        useradd -m -s /bin/bash -G sudo,adm "$username"
        log_info "Created user: $username"
    fi

    # Ensure user is in required groups
    local groups=("sudo" "adm")
    for group in "${groups[@]}"; do
        if ! groups "$username" | grep -qw "$group"; then
            usermod -aG "$group" "$username"
            log_info "Added $username to $group group"
        fi
    done
}

# Create system service user (no login shell)
# Usage: create_service_user "traefik"
create_service_user() {
    local username="$1"

    if id "$username" &>/dev/null; then
        log_info "Service user $username already exists"
    else
        useradd -r -M -s /sbin/nologin "$username"
        log_info "Created service user: $username"
    fi
}

# =============================================================================
# Firewall (UFW)
# =============================================================================

# Configure basic UFW firewall
# Usage: configure_ufw 2222 80 443
configure_ufw() {
    local ssh_port="${1:-22}"
    shift
    local allowed_ports=("$@")

    log_info "Configuring UFW firewall..."

    # Install UFW if not present
    if ! command_exists ufw; then
        apt-get install -y ufw
    fi

    # Reset to defaults
    ufw --force reset

    # Default policies
    ufw default deny incoming
    ufw default allow outgoing

    # Allow SSH
    ufw allow "$ssh_port"/tcp comment 'SSH'

    # Allow additional ports
    for port in "${allowed_ports[@]}"; do
        ufw allow "$port"/tcp
        log_info "Allowed port: $port"
    done

    # Enable firewall
    ufw --force enable

    log_info "UFW firewall configured and enabled"
    ufw status verbose
}

# =============================================================================
# Fail2ban
# =============================================================================

# Install and configure Fail2ban
# Usage: configure_fail2ban 2222
configure_fail2ban() {
    local ssh_port="${1:-22}"

    log_info "Configuring Fail2ban..."

    # Install if not present
    if ! command_exists fail2ban-client; then
        apt-get install -y fail2ban
    fi

    # Create local configuration
    cat > /etc/fail2ban/jail.local << EOF
[DEFAULT]
bantime = 3600
findtime = 600
maxretry = 5
banaction = ufw

[sshd]
enabled = true
port = ${ssh_port}
filter = sshd
logpath = /var/log/auth.log
maxretry = 3
bantime = 86400
EOF

    # Restart fail2ban
    systemctl enable fail2ban
    systemctl restart fail2ban

    log_info "Fail2ban configured and enabled"
}

# =============================================================================
# Automatic Updates
# =============================================================================

# Configure unattended upgrades for security updates
configure_auto_updates() {
    log_info "Configuring automatic security updates..."

    apt-get install -y unattended-upgrades apt-listchanges

    # Configure unattended upgrades
    cat > /etc/apt/apt.conf.d/50unattended-upgrades << 'EOF'
Unattended-Upgrade::Allowed-Origins {
    "${distro_id}:${distro_codename}";
    "${distro_id}:${distro_codename}-security";
    "${distro_id}ESMApps:${distro_codename}-apps-security";
    "${distro_id}ESM:${distro_codename}-infra-security";
};

Unattended-Upgrade::Package-Blacklist {
};

Unattended-Upgrade::AutoFixInterruptedDpkg "true";
Unattended-Upgrade::MinimalSteps "true";
Unattended-Upgrade::Remove-Unused-Dependencies "true";
Unattended-Upgrade::Automatic-Reboot "false";
Unattended-Upgrade::SyslogEnable "true";
EOF

    # Enable automatic updates
    cat > /etc/apt/apt.conf.d/20auto-upgrades << 'EOF'
APT::Periodic::Update-Package-Lists "1";
APT::Periodic::Unattended-Upgrade "1";
APT::Periodic::AutocleanInterval "7";
EOF

    log_info "Automatic security updates configured"
}

# =============================================================================
# NTP Configuration
# =============================================================================

# Configure NTP time synchronization
# Usage: configure_ntp "America/New_York"
configure_ntp() {
    local timezone="${1:-UTC}"

    log_info "Configuring NTP and timezone..."

    # Install chrony if not present
    if ! command_exists chronyd; then
        apt-get install -y chrony
    fi

    systemctl enable chrony
    systemctl start chrony

    # Set timezone
    timedatectl set-timezone "$timezone"

    log_info "NTP configured with timezone: $timezone"
}

# =============================================================================
# Audit Configuration
# =============================================================================

# Configure auditd for security logging
configure_auditd() {
    log_info "Configuring auditd..."

    # Install auditd
    apt-get install -y auditd audispd-plugins

    # Create audit rules
    cat > /etc/audit/rules.d/security.rules << 'EOF'
# Security Audit Rules

# Delete all existing rules
-D

# Buffer size
-b 8192

# Failure mode (1 = printk, 2 = panic)
-f 1

# Monitor critical files
-w /etc/passwd -p wa -k passwd_changes
-w /etc/shadow -p wa -k shadow_changes
-w /etc/group -p wa -k group_changes
-w /etc/sudoers -p wa -k sudoers_changes
-w /etc/ssh/sshd_config -p wa -k sshd_config_changes

# Monitor sudo usage
-w /var/log/sudo.log -p wa -k sudo_log

# Monitor Docker
-w /var/run/docker.sock -p rwxa -k docker_socket
-w /etc/docker -p wa -k docker_config

# Monitor authentication
-w /var/log/auth.log -p wa -k auth_log
-w /var/log/faillog -p wa -k faillog

# Monitor network configuration
-w /etc/hosts -p wa -k hosts_file
-w /etc/network -p wa -k network_config

# Immutable mode (enable after testing)
# -e 2
EOF

    # Restart auditd
    systemctl enable auditd
    systemctl restart auditd

    log_info "Auditd configured"
}

